/*
 * CastleCode
 *
 * By Craig Wood
 *
 * Copyright 2022 Craig Wood - http://github.com/w3ace
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * See <http://www.gnu.org/licenses/>.
 */

$fn=50;
/*
include <Polygon.scad>;
include <BezierCone.scad>;
include <Windows.scad>;
  */  
height = 40;
radius = 10;
style = [["type"],["watchtower"],["skin"],["bricked"]];


frand = rands(.87,1.18,400); // Random Numbers for all builds

greenfield();

buildtowers();

module buildtowers() {
maxtowers = 7;
    
    for (j = [0:0]) {
        for (i = [1:maxtowers]) {
              furand = [frand[i*20+j],frand[i*20+j+10],frand[i*20+j+1],frand[i*20+j+5],frand[i*20+j+15]];
         //   rotate([0,0,360/maxtowers*i])
    	translate ([i*50-180,0, 0])
            tower(height*myrand(furand,3),radius*myrand(furand,4),furand,"watchtower");
        }
    }
}

function myrand (rands,len,count=0,prod=1) = (count <= len) ? myrand (rands,len,count+1,prod*rands[rands(0,(len(rands)),1)[0]]) : prod;

module greenfield () {
    scale([1,1.3,1])
        color("green") Polygon(N=20,A=200,h=2);
}

module battlement (height, width, radius, numarm=18)
{
    {
        depth = width/2;
        for (i=[1:numarm])
            rotate([0,0,(360/numarm*i)]) // Rotate the arm after it's centered
                translate([radius-depth,0,height/2]) 
                    cube([depth,width,height],center=true); // Make the arm extend along the X axis

    }
}


module brick (height,radius,rands,brickspercourse = 12, segments = 1)
{
    brickwidth = (2*radius*3.14)/brickspercourse;
    for(k=[0:brickwidth*1.2:height]){
        for(i=[1:brickspercourse]) {
            for(j=[1:segments]) {

                location =360/brickspercourse*i+(j*360/brickspercourse/segments*.9) ;

                rotate([0,0,location])
                    translate([radius*.95,0,k]) color("lightsteelblue")
                        cube([radius*.15,(brickwidth/segments)*.9,brickwidth/2],center=true);
                    
                
                rotate([0,0,location+180/brickspercourse])
                    translate([radius*.95,0,(k+(brickwidth*.6))]) color("lightsteelblue")
                        cube([radius*.15,(brickwidth/segments)*.9,brickwidth/2],center=true);
                    }
                }
            }
}


module base (height,radius,rands,style)
{

    // module base
    //
    // tower add-ons for the base.

 
         baseheight = height*.25*myrand(rands,3);
        baseradius = radius*1.1*myrand(rands,2);
     if( rands[2]>.95) {
        cylinder(baseheight,baseradius,baseradius);
         brick(baseheight,baseradius,rands);
        // Taper
        if(rands[3]>1.1) {
            translate([0,0,baseheight])
                cylinder(height*.05*myrand(rands,3),baseradius,radius);
        // Battlements
        } else if (rands[1] >.92) { //} && (baseheight*2 > height)) {
            blockheight = round(baseheight*.2); //*abs(rands[2]));
            blockwidth = round(baseradius*.25); //*abs(rands[1]));
            translate([0,0,baseheight*.4])
                battlement(blockheight,blockwidth,baseradius*1.05);
        }
        // Polygon
    } else { // if(rands[2]>.85) {
        segments = rands(3,5,1)[0];
        polys = rands(7,11,1)[0];
        baseradius = radius*1.1*myrand(rands,2);
        for(i=[1:segments]) {
      //      echo (baseheight,polys,i,(baseradius+(.58/segments*i)),baseheight/segments*(segments-i+1));
            translate([0,0,baseheight-(baseheight/segments*i)])
            color("lightsteelblue")
                Polygon(N=polys,A=(baseradius+(.58*baseradius/segments*i)),h=baseheight/segments*(segments-i+1));
        }
    }
}


module watchtower (shaftheight,watchheight,height,radius,rands)
{

    // TODO: Hollow Tubes when built. 

    // Main Shaft
    difference() {
        union() {
            if(rands[0]>.88)
                base(height*rands[1],radius,rands,"watchtower");
            cylinder(shaftheight,r=radius);

            // Watchtower
            if(watchheight) {
                difference() {
                    union() {
                        translate([0,0,shaftheight])
                            cylinder(watchheight,radius*1.2*rands[1],radius*1.2); //*rands[0],radius*1.2*rands[1]); // Main Can
                        //      Bottom Round
                        translate([0,0,shaftheight])
                            cylinder(watchheight*.15,radius*1.2,radius*1.2); // Bottom Round
                        //      Top Round
                        toproundheight = round(watchheight*.2);
                        translate([0,0,round(shaftheight+watchheight-toproundheight)]) 
                            cylinder(toproundheight,radius*1.3,radius*1.3); // Top Round
                    }
                    translate([0,0,shaftheight+watchheight*.2])   
                        cylinder(watchheight*.8,radius*1.05,radius*1.05);
                }
            }

            // Peaked Roof
            blockheight = round(height*.1*rands[2]*rands[1]*rands[3]);
            blockwidth = round(radius*.5*rands[1]);
            if(rands[2]>1.05) {
                echo("Pitched Roof");
                translate([0,0,shaftheight+watchheight])
                    cylinder(height/2*rands[2],radius*1.6*rands[2],0);
                if(rands[1]>.90) {
                    translate([0,0,round(shaftheight+watchheight-blockheight)])
                        battlement(blockheight,blockwidth,radius*1.4,round(15*abs(rands[1])));
                }

            } else if (rands[2]>.98) {
                // Bezier Roof
                curve=rands(-2,10,1)[0];
                curve2=rands(0,20,1)[0]; 
                translate([0,0,shaftheight+watchheight])
                    BezCone(radius*1.4,h=20,curve=curve,curve2=curve2);
                echo("BezierRood", curve,curve2);
            } else {
                // Battlement Top
                blockheight = round(height*.1*myrand(rands,3));
                blockwidth = round(radius*.5*myrand(rands,1));
                translate([0,0,round(shaftheight+watchheight)])
                    battlement(blockheight,blockwidth,radius*1.4,round(10*abs(rands[1])));
                echo("Battlement Top",blockheight,blockwidth);
            } 
        }
        cylinder(shaftheight+watchheight,r=radius*.85);
    }   
}

module tower (height,radius,rands,style="watchtower")
{

    if (style == "watchtower") {
        // Main Stair Shaft
        shaftheight = round(height*rands[0]*rands[1]*rands[2]*rands[3]);
        watchheight = (myrand(rands,2)>.9) ? round(height*.4*rands[1]) : 0 ;
        echo("Heights",shaftheight,watchheight,radius);

        // Square Windows
        if(rands[0]>1){
            windowheight = round(height*.1*myrand(rands,3));
            windowwidth = round(radius*.5*myrand(rands,1));
            numwindows = round(rands(3,6,1)[0]);
            stup = round(rands(0,2,1)[0]);
            difference() {
                union() {
                    watchtower(shaftheight,watchheight,height,radius,rands);    
                    echo("Heights",shaftheight,watchheight,radius);

                    brick(shaftheight,radius,rands);
                    translate([0,0,shaftheight*.40])
                       squarewindow(windowheight,windowwidth,radius*1.12,numwindows,stup,frame=1.4);
                }
               translate([0,0,shaftheight*.4])
                    squarewindow(windowheight,windowwidth,radius*1.2,numwindows,stup);
            }
        } else {
            watchtower(shaftheight,watchheight,height,radius,rands);
        }
            
    }
            



}
